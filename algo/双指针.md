# 双指针

## 接雨水

这题很难搞清一些东西

1. 动态
2. 双指针


## 一开始我的思路

1. 层次
2. 双指针同向（快慢）
3. 方向上的变化，从低->高，从高->低
4. hash 表记录是否访问过

## 问题是什么？

1. 我觉得层次不太好，纵向的更符合直观感受
    - 层次的话，一层可能需要多次参与思考。比如 3,1,0,2,4，3和2之间，3和4之间，分别在第三层和第四层都要计算一次，复杂度太高了
    - 纵向的话，典型的迭代，这个点作为“低洼”，它的左右端点在哪里？**我不用关心其他点**（中间是否有某个突起），我只用关心我这个点本身**最终**能保存多少水。
2. 所以我现在的目的是怎么找到两边的最终影响我的高度
    - 先找到两边
        - 典型的相交指针向中间靠拢
        - i/j每经过一点，就看这个点是否能作为我的最终边界
        - 谁小谁走，目的是找到尽可能大的
        - 如果我本身就很高，那就作为下个点的边界（current）
        - 举例子，423从3开始，425从4开始，此时则不需要关注较大的那一个高度了
    - 然后取两边小的那个

所以总结一下，整个逻辑链是
1. 前后指针中间靠拢
2. 通过遍历，根据节点值趋势可直接获取到每个节点的最终位置，即使未来有更高的，也不会影响结果，应该结果基于极值中低的那一个。
    - 比如 42xxx5，最终是 `max(4, 5) - 2`
    - 向上趋势只更新极值，向下计算出最终结果


QA：
1. 一定是最终结果吗？
    - 由于指针方向是由两端极值中小的节点决定的，所以一旦趋势下降，则可以直接计算最终结果了。右边即使趋势还可以向上，对左极值也不影响 `min(max_left, max_right) - current_height`

伪代码写一下：

left = 0
right = len_height - 1
ans = 0
while left < right:
    if height_left <= height_right:
        if up:
            max_left = 
        else:
            ans += min(max_left, max_right) - current_height
        left += 1
    else:
        if up:
            max_right = 
        else:
            ans += min(...)
        right -= 1