# 14. Dynamic programming


1. dp数组怎么定义？
    - 关键是抽象出状态是怎么转移的？考虑一个中间值实例。典型的数学归纳法？如果前i-1个数的局部最优解确定，那么前i个呢？具体到背包问题就是两条路，选或者不选当前物品。


## 背包

### 0/1


打印一下，分析数据间的依赖

只依赖上一行，最终结果只取决于最后一行

【注意】内外层循环的下标，内层循环 [1. max_volume]，外层循环 [1, N+1)。f(i)表示前i-1个，不包括当前，f[N]表示前n个
#### QA

有没有优化空间？
1. 时间无法优化，本质是动态规划用时间换了空间
2. 由于上面分析了内层循环结果只依赖上一次内层循环（f(i)(j) -> f(i-1)(1...j)），所以可以优化空间复杂度
    - 优化的本质是通过覆盖f(i)的值，作为一个当前最优解，给下一层循环使用


为什么必须倒序？
1. 内层循环 f(j) 依赖 max(f(j), f(j-volume[i])+worth[i])。转换成二维则是依赖max(f(i-1)(j), f(i-1)(j-volume[i])+worth[i])。
    - 本质是依赖上一层的值，当你计算这一层时可直接获取计算。但是，如果正序，f(j-volume[i])会先被计算，那么此时该值对应二维的 f(i)(j-volume[i])+worth[i])，记录失效。
理解`dp[j] = dp[j] or dp[j - nums[i]]` => `cur_dp_j = before_dp_j or before_dp_j_minus_nums_i`
https://blog.csdn.net/aidway/article/details/50726472


TODO 思路对，下标不对也会有问题，考虑面面俱到、

### 完全背包

能够重复使用某个物品

这里就是多了一个k，外层的物品循环不变
因为加入了k，所以，还需要加一层循环来对每个k进行判断

## 最长上升子序列

本质：从无序中找到有序
有序的这个状态怎么保存？临时开一个数组保存？

为什么这个方法可行？
1. 通过迭代，每个下标对应的值只与前面的数相关
2. 124 -> 123 本质上对后面来说没什么负面影响（不会影响结果），只是末尾的数字变小了，潜在的答案增长了

为什么想到这个方法？
1. 最长上升 ---> 当前数字比之前的最长子序列的最后一个数字大，自然而然加上去，长度 + 1
2. 如果碰到一个比前面最长子序列最后一个数小，但是比倒数第二个或者第三个数大的呢？这时候的选择也会影响后面的继续计算。

具体思路？
1. 贪心 + 二分
    - 贪心是为了找到局部最优解，每个数字都能找到一个解
    - 二分是为了加快查找速度
2. 处理一些边界问题
    - d[] 初始化0


### DP
1. 由于子序列不连续，简单的DP需要对比当前下标前面所有的数据 last_dp_0--j
2. 此时的时间复杂度就是O(n^2)

### 

性质：
1. 不能改变顺序
2. 逐个判断